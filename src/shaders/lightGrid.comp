#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WORKGROUP_SIZE 32

layout(local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1) in;

layout (set = 0, binding = 0, rgba32f) uniform image3D targetImage;

// Modeling NVDF's
// 512 x 512 x 64
// R: Dimentional Profile 
// G: Detail Type
// B: Density Scale
// A: SDF
layout(set = 1, binding = 0) uniform sampler3D modelingNVDFTexture;

layout(set = 1, binding = 1) uniform sampler3D fieldNVDFTexture;
layout(set = 1, binding = 2) uniform sampler3D cloudDetailNoiseTexture;


layout(set = 2, binding = 0) uniform TimeObject {
    float deltaTime;
    float totalTime;
    float sunPositionX;
    float sunPositionY;
    float sunPositionZ;
} time;


float GetVoxelCloudProfileDensity(vec3 coord) {

    vec3 inSamplePosition = vec3(coord.x/256, coord.y/256, coord.z/32);

    vec4 NVDF = texture(modelingNVDFTexture, inSamplePosition).rgba;
    float dimensionalProfile = NVDF.r;
    float densityScale = NVDF.b;

    if (dimensionalProfile > 0.0) {
        return dimensionalProfile * densityScale;
    }

    return 0;
}

bool InBoundary(vec3 coord)
{
    return coord.x >= 0 && coord.x < 256
        && coord.y >= 0 && coord.y < 256
        && coord.z >= 0 && coord.z < 32;
}

void main() {
   ivec3 coord = ivec3(gl_GlobalInvocationID.xyz);

    // Update Sun
    vec3 sunPos = vec3(time.sunPositionX, time.sunPositionY, time.sunPositionZ);
    vec3 sunDir = normalize(sunPos);

    float density = GetVoxelCloudProfileDensity(coord);

    if(density <= 0)
    {
        imageStore(targetImage, coord, vec4(0, 0, 0, 0));
		return;
    }

    vec3 nextCoord = coord + sunDir;

    while(InBoundary(nextCoord))
    {
       density += GetVoxelCloudProfileDensity(nextCoord);
       nextCoord += sunDir;
    }
     
    vec4 finalColor = vec4(density, 0, 0, 0);
    imageStore(targetImage, coord, finalColor);
}
