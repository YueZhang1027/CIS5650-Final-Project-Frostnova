#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WORKGROUP_SIZE 32

#define PI 3.14159265
#define ONE_OVER_FOURPI 0.07957747154594767

// #define SUN_LOCATION vec3(0.0, 0.0, 0.0)

// Cloud animation
#define CLOUD_ANIMATE_SPEED 10.f
#define CLOUD_WIND_OFFSET vec2(0.1, 0.1)

#define EPSILON 0.1

// Mip Map
#define USE_FINE_DETAIL_MIPMAP false
#define USE_FINE_DETAIL_MIPMAP_DISTANCE_SCALE 10.0

// Raymarching
#define MAX_RAYMARCHING_DISTANCE 500.0
#define VIEW_RAY_TRANSIMITTANCE_LIMIT 0.01
#define VOXEL_BOUND_MIN vec3(-1024.0, -1024.0, -128.0)
#define VOXEL_BOUND_MAX vec3(1024.0, 1024.0, 128.0)

// Density
#define DENSITY_SCALE 0.01

layout(local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE) in;

layout (set = 0, binding = 0, rgba32f) uniform image2D targetImage;
// layout (set = 1, binding = 0, rgba32f) uniform readonly image2D sourceImage;

layout(set = 1, binding = 0) uniform CameraObject {
    mat4 view;
    mat4 proj;
    vec4 cameraPosition;
} camera;

layout(set = 1, binding = 2) uniform CameraParamObject {
    float halfTanFOV;
    float aspectRatio;
    int pixelOffset;
} cameraParam;

// Modeling NVDF's
// 512 x 512 x 64
// R: Dimentional Profile 
// G: Detail Type
// B: Density Scale
// A: SDF
layout(set = 2, binding = 0) uniform sampler3D modelingNVDFTexture;

// Field Data NVDF
// 512 x 512 x 64
// layout(set = 2, binding = 1) uniform sampler3D fieldNVDFTexture;

// Detail Noise
// 128 * 128 * 128
layout(set = 2, binding = 1) uniform sampler3D cloudDetailNoiseTexture;

layout(set = 3, binding = 0) uniform TimeObject {
    float deltaTime;
    float totalTime;
} time;

// structs
struct VoxelCloudModelingData {
    float mDimensionalProfile;
    float mDetailType;
    float mDensityScale;
    float mSdf;
};

struct VoxelCloudDensitySamples {
    float mProfile; // profile
    float mFull;    // detail
};

struct CloudRenderingRaymarchInfo {
    float mDistance;       // ray marching distance
    float mCloudDistance;  // distance to cloud
    float mStepSize;       // step size
    vec2 mLimit;           // limit
};

struct CloudRenderingPixelData {
    float mDensity;
    float mTransmittance;
    vec3 mColor;
};

struct Ray {
	vec3 mOrigin;
	vec3 mDirection;
};

struct Intersection {
    vec3 mNormal;
    vec3 mPoint;
    float mTime;
};


//--------------------------------------------------------
//					ATMOSPHERE FUNCTIONS
//--------------------------------------------------------


//--------------------------------------------------------
//					TOOL BOX FUNCTIONS
//--------------------------------------------------------
float ValueRemap(float inValue, float inOldMin, float inOldMax, float inMin, float inMax) {
    float old_min_max_range = (inOldMax - inOldMin);
    float clamped_normalized = clamp((inValue - inOldMin) / old_min_max_range, 0, 1);
    return inMin + (clamped_normalized * (inMax - inMin));
}


float ValueErosion(float inValue, float inOldMin) {
    // derrived from Set-Range, this function uses the oldMin to erode or inflate the input value. - inValues inflate while + inValues erode
    float old_min_max_range = (1.0 - inOldMin);
    float clamped_normalized = clamp((inValue - inOldMin) / old_min_max_range, 0, 1);
    return (clamped_normalized);
}

float GetFractionFromValue(float inValue, float inMin, float inMax) {
    return clamp((inValue - inMin) / (inMax - inMin), 0, 1);
}

float GetVoxelCloudMipLevel(CloudRenderingRaymarchInfo inRaymarchInfo, float inMipLevel) {
    // Apply Distance based Mip Offset
    float mipmap_level = USE_FINE_DETAIL_MIPMAP ? inMipLevel : log2(1.0 + abs(inRaymarchInfo.mDistance * USE_FINE_DETAIL_MIPMAP_DISTANCE_SCALE)) + inMipLevel;
    return mipmap_level;
}

vec3 GetSampleCoord(vec3 inSamplePosition) {
    vec3 sample_coord = (inSamplePosition - VOXEL_BOUND_MIN) / (VOXEL_BOUND_MAX - VOXEL_BOUND_MIN);
    // if (sample_coord.x < 0.0 || sample_coord.x > 1.0 || sample_coord.y < 0.0 || sample_coord.y > 1.0 || sample_coord.z < 0.0 || sample_coord.z > 1.0) {
	// 	return sample_coord;
	// }

    sample_coord = vec3(1.0f) - sample_coord;
    return sample_coord;
}

//--------------------------------------------------------
//					Density Sample Functions
//--------------------------------------------------------
VoxelCloudModelingData GetVoxelCloudModelingData(vec3 inSamplePosition, float inMipLevel) {
    VoxelCloudModelingData modeling_data;
    vec4 Modeling_NVDF = texture(modelingNVDFTexture, inSamplePosition).rgba;
    modeling_data.mDimensionalProfile = Modeling_NVDF.r;
    modeling_data.mDetailType = Modeling_NVDF.g;
    modeling_data.mDensityScale = Modeling_NVDF.b;
    modeling_data.mSdf = ValueRemap(Modeling_NVDF.a, 0.0f, 1.0f, -256.0f, 4096.0f);

    return modeling_data;
}

// Detail density sample
float GetUprezzedVoxelCloudDensity(CloudRenderingRaymarchInfo inRaymarchInfo, vec3 inSamplePos, float inDimensionalProfile, float inType, float inDensityScale, float inMipLevel, bool inHFDetails)
{
    // Step1-Apply wind offset
    inSamplePos -= vec3(CLOUD_WIND_OFFSET.x, CLOUD_WIND_OFFSET.y, 0.0) * CLOUD_ANIMATE_SPEED * time.totalTime;

    // Step2-Sample noise
    float mipmap_level = GetVoxelCloudMipLevel(inRaymarchInfo, inMipLevel);
    // R��Low Freq "Curl-Alligator", G:High Freq "Curl-Alligator", B:Low Freq "Alligator", A: High Freq "Alligator"

    vec4 noise = texture(cloudDetailNoiseTexture, inSamplePos * 0.05); // TODO: check freq

    // Step3-Define Detail Erosion
    // wispy
    float wispy_noise = mix(noise.r, noise.g, inDimensionalProfile);

    // billowy
    float billowy_type_gradient = pow(inDimensionalProfile, 0.25);
    float billowy_noise = mix(noise.b * 0.3, noise.a * 0.3, billowy_type_gradient);

    // High Noise composite - blend to wispy as the density scale decreases.
    float noise_composite = mix(wispy_noise, billowy_noise, inType);

    // high frequency detail?
    if (inHFDetails)
    {
        float hhf_wisps = 1.0 - pow(abs(abs(noise.g * 2.0 - 1.0) * 2.0 - 1.0), 4.0);
        float hhf_billows = pow(abs(abs(noise.a * 2.0 - 1.0) * 2.0 - 1.0), 2.0);
        float hhf_noise = clamp(mix(hhf_wisps, hhf_billows, inType), 0, 1);
        float hhf_noise_distance_range_blender = ValueRemap(inRaymarchInfo.mDistance, 50.0, 150.0, 0.9, 1.0); // unit: meter
        noise_composite = mix(hhf_noise, noise_composite, hhf_noise_distance_range_blender);
    }

    // composite noise
    float uprezzed_density = ValueErosion(inDimensionalProfile, noise_composite);
    float powered_density_scale = pow(clamp(inDensityScale, 0, 1), 4.0);
    uprezzed_density *= powered_density_scale;

    // make low frequency region more sharp
    uprezzed_density = pow(uprezzed_density, mix(0.3, 0.6, max(EPSILON, powered_density_scale)));

    if (inHFDetails)
    {
        float distance_range_blender = GetFractionFromValue(inRaymarchInfo.mDistance, 50.0, 150.0);
        uprezzed_density = pow(uprezzed_density, mix(0.5, 1.0, distance_range_blender)) * mix(0.666, 1.0, distance_range_blender);
    }

    return uprezzed_density;
}


VoxelCloudDensitySamples GetVoxelCloudDensitySamples(CloudRenderingRaymarchInfo inRaymarchInfo, VoxelCloudModelingData modeling_data, vec3 samplePosition, float inMipLevel, bool inHFDetails) {
    VoxelCloudDensitySamples density_samples;
    density_samples.mProfile = 0.0;
	density_samples.mFull = 0.0;

    float dimensional_profile = modeling_data.mDimensionalProfile;
    float type = modeling_data.mDetailType;
    float density_scale = modeling_data.mDensityScale;

    if (dimensional_profile > 0.0) {
        density_samples.mProfile = dimensional_profile * density_scale;

        density_samples.mFull = GetUprezzedVoxelCloudDensity(inRaymarchInfo, samplePosition, dimensional_profile, type, density_scale, inMipLevel, inHFDetails) // TODO: check profile
                                    * ValueRemap(inRaymarchInfo.mDistance, 10.0, 120.0, 0.25, 1.0);
    }

    return density_samples;
}

//--------------------------------------------------------
//					Lighting Functions
//--------------------------------------------------------
float HG(float cos_angle, float g) {
    float g2 = g * g;
    float val = ((1.0 - g2) / pow(1.0 + g2 - 2.0 * g * cos_angle , 1.5)) * ONE_OVER_FOURPI;
    return val;
}

// float InOutScatter(float cos_angle) {
//     float first_hg = HG(cos_angle, cloud_inscatter);
//     float second_hg = cloud_silver_intensity * pow (clamp(cos_angle, 0, 1), cloud_silver_exponent);
//     float in_scatter_hg = max(first_hg, second_hg);
//     float out_scatter_hg = HG (cos_angle , -cloud_outscatter);
//     return lerp(in_scatter_hg, out_scatter_hg ,cloud_in_vs_outscatter);
// }

// float Attenuation(float density_to_sun, float cos_angle) {
//     float prim = exp(-cloud_beer * density_to_sun);
//     float scnd = exp(-cloud_beer * cloud_attuention_clampval) * 0.7;
//     //reduce clamping while facing the sun
//     float checkval = ValueRemap(cos_angle, 0.0, 1.0, scnd, scnd * 0.5);
//     return max(checkval, prim);
//  }
// 
//  float OutScatterAmbient(float density, float percent_height){
//      float depth = cloud_outscatter_ambient * pow(density,ValueRemap(percent_height, 0.3, 0.9, 0.5, 1.0));
//      float vertical = pow(clamp(ValueRemap(percent_height, 0.0, 0.3, 0.8, 1.0)) ,0.8);
//      float out_scatter = depth * vertical;
//      out_scatter = 1.0 - clamp(out_scatter, 0.0f, 1.0f);
//      return out_scatter;
// }

// vec3 CalculateLight(float density, float density_to_sun, float cos_angle, float percent_height, float bluenoise, float dist_along_ray {
//     float attenuation_prob = Attenuation(density_to_sun, cos_angle);
//     float ambient_out_scatter = OutScatterAmbient(density, percent_height);

//     // Can be calculated once for each march but gave no/tiny per improvements.
//     const float sun_highlight = InOutScatter(cos_angle);
//     float attenuation = attenuation_prob * sun_highlight * ambient_out_scatter;

//     // Ambient min (dist_along_ray used so that far away regions (huge steps) arent calculated (wrongly))
//     attenuation = max(density * cloud_ambient_minimum * (1 - pow(clamp(dist_along_ray / 4000, 0.0f, 1.0f), 2)), attenuation);

//     //combat banding a bit more
//     attenuation += bluenoise * 0.003;
//     vec3 ret_color = attenuation * sun_color;
//     return ret_color;
//  }

void IntegrateCloudSampleData(VoxelCloudDensitySamples sampleData, float cloud_distance, CloudRenderingRaymarchInfo raymarch_info, inout CloudRenderingPixelData ioPixelData, bool inHFDetails) {
    ioPixelData.mDensity += sampleData.mFull;
    float ms_volume = sampleData.mProfile;

    // Calculate Density to Sun
    float density_to_sun;

    // ��������ɢ��������inSunLightSummedDensitySamples��Ԥ�ȼ����DensityToSun
    // float sun_dot = ray
    // ms_volume *= exp(-density_to_sun * ValueRemap(sun_dot, 0.0, 0.9, 0.25, ValueRemap(cloud_distance, -128.0, 0.0, 0.05, 0.25)));

    // // ͬ2.5D��һ����Ҳʹ��ά�����������ƻ�����
    // float ambient_scattering = pow(1.0 - dimensional_profile, 0.5);
    // // �������Ļ�����
    // float ambient_scattering = pow(1.0 - dimensional_profile, 0.5) * exp(-summed_ambient_density);
    // 
    // // �ڶ���Դ֧�֣���Ҫ����Ϊ�ֲ���Դ�ĵ��Դ
    // float potential_energy = pow( 1.0 - (d1 / radius), 12.0);
    // float pseudo_attenuation = (1.0 - saturate(density * 5.0)); 
    // float glow_energy = potential_energy * pseudo_attenuation;
}

//--------------------------------------------------------
//					Raymarching Functions
//--------------------------------------------------------
// float GetVoxelCloudDistance(vec3 inSamplePosition) {
//     vec3 sampled_color = texture(fieldNVDFTexture, inSamplePosition).rgb;
//     float result = dot(sampled_color, vec3(1.0, 0.03529415, 0.00069204));
//     return ValueRemap(sampled_color.r, 0, 1, -256, 4096);
// }

void SetRaymarchLimit(Ray ray, inout CloudRenderingRaymarchInfo raymarch_info) {
    float tmin = 4096.0f, tmax = -4096.0f;

    if (ray.mOrigin.x >= VOXEL_BOUND_MIN.x && ray.mOrigin.x <= VOXEL_BOUND_MAX.x && 
        ray.mOrigin.y >= VOXEL_BOUND_MIN.y && ray.mOrigin.y <= VOXEL_BOUND_MAX.y && 
        ray.mOrigin.z >= VOXEL_BOUND_MIN.z && ray.mOrigin.z <= VOXEL_BOUND_MAX.z) {
		tmin = 0.0f;
	}

    // x axis
    if (ray.mDirection.x != 0.0f) {
		float t1 = abs((VOXEL_BOUND_MAX.x - ray.mOrigin.x) / ray.mDirection.x);
        vec3 p = ray.mOrigin + ray.mDirection * t1;
        if (p.y >= VOXEL_BOUND_MIN.y && p.y <= VOXEL_BOUND_MAX.y && p.z >= VOXEL_BOUND_MIN.z && p.z <= VOXEL_BOUND_MAX.z) {
            tmin = min(tmin, t1);
            tmax = max(tmax, t1);
		}

        float t2 = abs((VOXEL_BOUND_MIN.x - ray.mOrigin.x) / ray.mDirection.x);
		p = ray.mOrigin + ray.mDirection * t2;
		if (p.y >= VOXEL_BOUND_MIN.y && p.y <= VOXEL_BOUND_MAX.y && p.z >= VOXEL_BOUND_MIN.z && p.z <= VOXEL_BOUND_MAX.z) {
			tmin = min(tmin, t2);
			tmax = max(tmax, t2);
		}
	} 

	// y axis
	if (ray.mDirection.y != 0.0f) {
		float t1 = abs((VOXEL_BOUND_MAX.y - ray.mOrigin.y) / ray.mDirection.y);
		vec3 p = ray.mOrigin + ray.mDirection * t1;
		if (p.x >= VOXEL_BOUND_MIN.x && p.x <= VOXEL_BOUND_MAX.x && p.z >= VOXEL_BOUND_MIN.z && p.z <= VOXEL_BOUND_MAX.z) {
			tmin = min(tmin, t1);
			tmax = max(tmax, t1);
		}

        float t2 = abs((VOXEL_BOUND_MIN.y - ray.mOrigin.y) / ray.mDirection.y);
        p = ray.mOrigin + ray.mDirection * t2;
		if (p.x >= VOXEL_BOUND_MIN.x && p.x <= VOXEL_BOUND_MAX.x && p.z >= VOXEL_BOUND_MIN.z && p.z <= VOXEL_BOUND_MAX.z) {
			tmin = min(tmin, t2);
			tmax = max(tmax, t2);
		}
	} 

	// z axis
	if (ray.mDirection.z != 0.0f) {
		float t1 = abs((VOXEL_BOUND_MAX.z - ray.mOrigin.z) / ray.mDirection.z);
		vec3 p = ray.mOrigin + ray.mDirection * t1;
		if (p.x >= VOXEL_BOUND_MIN.x && p.x <= VOXEL_BOUND_MAX.x && p.y >= VOXEL_BOUND_MIN.y && p.y <= VOXEL_BOUND_MAX.y) {
			tmin = min(tmin, t1);
			tmax = max(tmax, t1);
		}

        float t2 = abs((VOXEL_BOUND_MIN.z - ray.mOrigin.z) / ray.mDirection.z);
		p = ray.mOrigin + ray.mDirection * t2;
        if (p.x >= VOXEL_BOUND_MIN.x && p.x <= VOXEL_BOUND_MAX.x && p.y >= VOXEL_BOUND_MIN.y && p.y <= VOXEL_BOUND_MAX.y) {
			tmin = min(tmin, t2);
			tmax = max(tmax, t2);
		}
	}

    raymarch_info.mLimit = vec2(tmin, tmax);
    raymarch_info.mDistance = raymarch_info.mLimit.x;
}

void RaymarchVoxelClouds(Ray ray, inout CloudRenderingPixelData ioPixelData) {
    CloudRenderingRaymarchInfo raymarch_info;
    raymarch_info.mDistance = 0.0;

    // Intersect with bounding box
    SetRaymarchLimit(ray, raymarch_info);

    float cosTheta = dot(ray.mDirection, normalize(vec3(-1, -1, 0.0f)));
    float henyeyGreenstein = HG(cosTheta, 0.2f);
    float absorptionCoefficient = 0.5f;


    while (ioPixelData.mTransmittance > VIEW_RAY_TRANSIMITTANCE_LIMIT &&
         raymarch_info.mDistance < min(MAX_RAYMARCHING_DISTANCE, raymarch_info.mLimit.y)) {
         vec3 sample_position = ray.mOrigin + ray.mDirection * raymarch_info.mDistance;
         vec3 sample_coord = GetSampleCoord(sample_position);

         if (sample_coord.x >= 0.0 && sample_coord.x <= 1.0 && sample_coord.y >= 0.0 && sample_coord.y <= 1.0 && sample_coord.z >= 0.0 && sample_coord.z <= 1.0) { 
             VoxelCloudModelingData modeling_data = GetVoxelCloudModelingData(sample_coord, 0.0f);
             
             // Adaptive Step Size
             float adaptive_step_size = max(1.0, max(sqrt(raymarch_info.mDistance), EPSILON) * 0.08);

             raymarch_info.mCloudDistance = modeling_data.mSdf; // raymarch_info.mCloudDistance = GetVoxelCloudDistance(sample_position);

             // Max SDF and Step Size
             raymarch_info.mStepSize = max(raymarch_info.mCloudDistance, adaptive_step_size);
     
             // Jitter

             if (raymarch_info.mCloudDistance < 0.0) {
		         VoxelCloudDensitySamples voxel_cloud_sample_data = GetVoxelCloudDensitySamples(raymarch_info, modeling_data, sample_position, 1.0f, true); // sample_position?
                 
                 if (voxel_cloud_sample_data.mProfile > 0.0f) {
			         // IntegrateCloudSampleData(voxel_cloud_sample_data, raymarch_info.mCloudDistance, raymarch_info, ioPixelData, false);

                     // ioPixelData.mTransmittance *= exp(-absorptionCoefficient * voxel_cloud_sample_data.mFull * raymarch_info.mStepSize);

                     float beersLaw = exp(-voxel_cloud_sample_data.mFull * raymarch_info.mStepSize);
                     float beersModulated = max(beersLaw, 0.7 * exp(-0.25 * voxel_cloud_sample_data.mFull * raymarch_info.mStepSize));
                     beersLaw = mix(beersLaw, beersModulated, -cosTheta * 0.5 + 0.5);
                     // 
                     // float inScatter = 0.1 + pow(voxel_cloud_sample_data.mProfile, ValueRemap(0.5, 0.3, 0.85, 0.5, 2.0));
                     // 
                     ioPixelData.mTransmittance = mix(ioPixelData.mTransmittance, henyeyGreenstein * beersLaw, (1.0f - ioPixelData.mDensity));

                     ioPixelData.mDensity += voxel_cloud_sample_data.mFull;
                     if (ioPixelData.mDensity > 1.0f) {
                        ioPixelData.mDensity = 1.0f;
                        break;
                     }
		         }
             }
         }
         raymarch_info.mDistance += raymarch_info.mStepSize;
    }
}

Ray GenerateRay(vec2 uv) {
    Ray ray;

    vec3 camLook =   normalize(vec3(camera.view[0][2], camera.view[1][2], camera.view[2][2]));
    vec3 camRight =  normalize(vec3(camera.view[0][0], camera.view[1][0], camera.view[2][0]));
    vec3 camUp =     normalize(vec3(camera.view[0][1], camera.view[1][1], camera.view[2][1]));

    vec2 screenPoint = uv * 2.0 - 1.0;

    vec3 cameraPos = camera.cameraPosition.xyz;
    vec3 refPoint = cameraPos - camLook;
    vec3 p = refPoint 
             + cameraParam.aspectRatio * screenPoint.x * cameraParam.halfTanFOV * camRight 
             - screenPoint.y * cameraParam.halfTanFOV * camUp;

    ray.mOrigin = cameraPos;
    ray.mDirection = normalize(p - cameraPos);

    return ray;
}

//--------------------------------------------------------
//					Main Functions
//--------------------------------------------------------

void main() {
    // Get UV
    ivec2 dim = imageSize(targetImage);

    // 1/16 of the pixels after reproject compute shader
    // ivec2 pixel = ivec2(gl_GlobalInvocationID.xy) * 4 + ivec2(cameraParam.pixelOffset % 4, cameraParam.pixelOffset / 4);
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = vec2(pixel) / dim; 

    // Get Camera Ray
    Ray ray = GenerateRay(uv);

    CloudRenderingPixelData ioPixelData;
    ioPixelData.mDensity = 0.0;
    ioPixelData.mTransmittance = 1.0;
    ioPixelData.mColor = vec3(0.0);

	// Raymarch
	RaymarchVoxelClouds(ray, ioPixelData);
     
    // Background color
    vec3 bgColor = vec3(0.23f, 0.36f, 0.47f);
    
    float accumDensity = ioPixelData.mDensity;
    float transmittance = ioPixelData.mTransmittance;
    // accumDensity *= smoothstep(0, 1, min(1, ValueRemap(ray.mDirection.y, 0, 0.1, 0, 1)));
    vec3 cloudColor = (10.f * vec3(0.97, 0.86, 0.8) * vec3(max(0.0, transmittance)) + 0.1f * bgColor * exp(-transmittance)); 
    
    vec4 finalColor = vec4(mix(bgColor, cloudColor, accumDensity), 1.0f);
    finalColor.a *= max(1.0 - accumDensity, 0.0);
    imageStore(targetImage, pixel, finalColor);
}
