#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WORKGROUP_SIZE 32

#define PI 3.14159265
#define E 2.718281828459
#define DEG2RAD 0.01745f

// Hard coded light direction
vec3 _lightDir = vec3(0, -1, 0);
vec3 _lightPos = vec3(0, 20, 0);

// Hard coded cloud boundary
float _boundScale = 1;
vec3 _boundsMin = vec3(-200, -25, -150) * _boundScale;
vec3 _boundsMax = vec3(200, 25, 150) * _boundScale;

// Cloud Shape Parameters
float _shapeTiling = 0.001;
float _detailTiling = 0.02;
float _shapeSpeed = 0.02;
float _detailSpeed = 0.3;
float _heightWeight = 0.247;
vec4 _shapeNoiseWeights = vec4(4, 19.9, -3.18, -18.4);   // Magic number...
float _detailWeights = 5.5;

// Cloud Lighting Parameters
float _silverIntensity = 1.05;
float _silverSpread = 1.14;
float _eccentricity = 0.18;
float _lightAbsorptionTowardSun = 1.38;
float _lightAbsorptionThroughCloud = 0.85;
float _darkness = 0.5;

vec3 _colA = vec3(1, 0.92, 0.77);
vec3 _colB = vec3(0, 0.09, 0.47);
float _colorOffset1 = -11;
float _colorOffset2 = 2.1;

//TODO: Add Time
float _Time = 0;



layout(local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE) in;

layout (set = 0, binding = 0, rgba32f) uniform image2D targetImage;
layout (set = 1, binding = 0, rgba32f) uniform readonly image2D sourceImage;

layout(set = 2, binding = 0) uniform CameraObject {
    mat4 view;
    mat4 proj;
    vec4 cameraPosition;
} camera;

layout(set = 2, binding = 1) uniform CameraObjectPrev {
    mat4 view;
    mat4 proj;
    vec4 cameraPosition;
} cameraPrev;

layout(set = 3, binding = 0) uniform sampler3D lowResCloudShape;
layout(set = 3, binding = 1) uniform sampler3D hiResCloudShape;
layout(set = 3, binding = 2) uniform sampler2D weatherMap;

layout(set = 4, binding = 0) uniform TimeObject {
    float deltaTime;
    float totalTime;
} time;

float remap(float originalValue, float originalMin, float originalMax, float newMin, float newMax)
{
    return newMin + (((originalValue - originalMin) / (originalMax - originalMin)) * (newMax - newMin));
}

vec2 rayBoxDst(vec3 boundsMin, vec3 boundsMax, vec3 rayOrigin, vec3 invRaydir)
{
     vec3 t0 = (boundsMin - rayOrigin) * invRaydir;
     vec3 t1 = (boundsMax - rayOrigin) * invRaydir;
     vec3 tmin = min(t0, t1);
     vec3 tmax = max(t0, t1);

     float dstA = max(max(tmin.x, tmin.y), tmin.z); 
     float dstB = min(tmax.x, min(tmax.y, tmax.z)); 

     float dstToBox = max(0, dstA);
     float dstInsideBox = max(0, dstB - dstToBox);
     return vec2(dstToBox, dstInsideBox);
 }

float sampleDensity(vec3 rayPos) 
{
     vec4 boundsCentre = vec4((_boundsMax + _boundsMin) * 0.5, 0);
     vec3 size = _boundsMax - _boundsMin;
     float speedShape = time.totalTime * _shapeSpeed;
     float speedDetail =  time.totalTime * _detailSpeed;

     vec3 uvwShape = rayPos * _shapeTiling + vec3(speedShape, speedShape * 0.2, 0);
     vec3 uvwDetail = rayPos * _detailTiling + vec3(speedDetail, speedDetail * 0.2, 0);

     vec2 uv = (size.xz * 0.5f + (rayPos.xz - boundsCentre.xz)) / max(size.x, size.z);
     vec2 uvWeather = uv + vec2(speedShape * 0.4, 0);

     vec4 weatherMap = texture(weatherMap, uvWeather);
     vec4 shapeNoise = texture(lowResCloudShape, uvwShape);
     vec4 detailNoise = texture(hiResCloudShape, uvwDetail);

     // Edge 
     const float containerEdgeFadeDst = 50;
     float dstFromEdgeX = min(containerEdgeFadeDst, min(rayPos.x - _boundsMin.x, _boundsMax.x - rayPos.x));
     float dstFromEdgeZ = min(containerEdgeFadeDst, min(rayPos.z - _boundsMin.z, _boundsMax.z - rayPos.z));
     float edgeWeight = min(dstFromEdgeZ, dstFromEdgeX) / containerEdgeFadeDst;

     // Get desity height gradient for points
     // TODO: change to CloudType version when we have CloudType map
     float gMin = remap(weatherMap.x, 0, 1, 0.1, 0.6);
     float gMax = remap(weatherMap.x, 0, 1, gMin, 0.9);
     float heightPercent = (rayPos.y - _boundsMin.y) / size.y;
     float heightGradient = clamp(remap(heightPercent, 0.0, gMin, 0, 1), 0, 1) 
                          * clamp(remap(heightPercent, 1, gMax, 0, 1), 0, 1);
     float heightGradient2 = clamp(remap(heightPercent, 0.0, weatherMap.r, 1, 0), 0, 1) 
                           * clamp(remap(heightPercent, 0.0, gMin, 0, 1), 0, 1);
     heightGradient = clamp(mix(heightGradient, heightGradient2, _heightWeight), 0, 1);
     heightGradient *= edgeWeight;

     vec4 normalizedShapeWeights = _shapeNoiseWeights / dot(_shapeNoiseWeights, vec4(1));
     float shapeFBM = dot(shapeNoise, normalizedShapeWeights) * heightGradient;
     float baseShapeDensity = shapeFBM;

     if (baseShapeDensity > 0)
     {
         float detailFBM = pow(detailNoise.r, _detailWeights);
         float oneMinusShape = 1 - baseShapeDensity;
         float detailErodeWeight = oneMinusShape * oneMinusShape * oneMinusShape;
         float cloudDensity = baseShapeDensity - detailFBM * detailErodeWeight;
         return clamp(cloudDensity, 0, 1);
     }
     return 0; 
}

// Lighting functions

float getHeightFractionForPoint(vec3 p)
{   
    float heightFraction = (p.z - _boundsMin.y) / (_boundsMax.y - _boundsMin.y);
    return clamp(heightFraction, 0, 1);
}

float henyeyGreenstein(float cosAngle, float eccentricity)
{
    float g2 = eccentricity * eccentricity;
    return ((1.0 - g2) / pow((1.0 + g2 - 2.0 * eccentricity * cosAngle), 1.5)) / (4.0 * PI);
}

float getDirectScatterProbability(float cosTheta)
{
    return max(henyeyGreenstein(cosTheta, _eccentricity), _silverIntensity * henyeyGreenstein(cosTheta, 0.99 - _silverSpread));
}

float getAttenuationProbability(float sampleDensity)
{
    return max(exp(-sampleDensity), (exp(-sampleDensity * 0.25) * 0.7));
}

float getInScatterProbability(vec3 p, float dsLoded)
{
    float heightFraction = getHeightFractionForPoint(p);
    float depthProbability = 0.05 + pow(dsLoded, remap(heightFraction, 0.3, 0.85, 0.5, 2.0));
    float verticalProbability = pow(remap(heightFraction, 0.07, 0.14, 0.1, 1.0), 0.8);
    float inScatterProbability = depthProbability * verticalProbability;

    return inScatterProbability;
}

float getLightEnergy(vec3 p, float dl, float dsLoded, float cosAngle)
{
    float attenuationProbability = getAttenuationProbability(dl);
    float inScatterProbability = getInScatterProbability(p, dsLoded);
    float phaseProbability = getDirectScatterProbability(cosAngle);
    float lightEnergy = attenuationProbability * inScatterProbability * phaseProbability;

    return lightEnergy;
}

vec3 lightmarch(vec3 p)
{
    vec3 dirToLight = _lightPos; 
    float dstInsideBox = rayBoxDst(_boundsMin, _boundsMax, p, 1 / dirToLight).y;
    float stepSize = dstInsideBox / 8;
    float totalDensity = 0;

    for (int step = 0; step < 8; step++)
    { 
        p += dirToLight * stepSize; 
        totalDensity += max(0, sampleDensity(p));
    }
  
    float lightEnergy = exp(-totalDensity * _lightAbsorptionTowardSun);
    vec3 white = vec3(1, 1, 1);
    vec3 cloudColor = mix(_colA, white, clamp(lightEnergy * _colorOffset1, 0, 1));
    cloudColor = mix(_colB, cloudColor, clamp(pow(lightEnergy * _colorOffset2, 3), 0, 1));
    return _darkness + lightEnergy * _darkness * cloudColor;
}

vec3 lightmarchAlongCone(vec3 p, float stepSize, float cosAngle)
{
    vec3 dirToLight = _lightPos; 
    vec3 lightStep = stepSize * dirToLight;
    float coneRadius = 1.0;
    float coneStep = 1.0 / 6;
    float densityAlongCone = 0.0;
    float lod = 0.0;
    float lodStride = 1.0 / 6;
  
    float totalDensity = 0;

    for (int i = 0; i <= 6; i++)
    {
        densityAlongCone += max(0, sampleDensity(p));
        p += lightStep;
        coneRadius += coneStep;
        lod += lodStride;
    }
  
    float lightEnergy = getLightEnergy(p, densityAlongCone, lod, cosAngle);
  
    lightEnergy = exp(-lightEnergy * _lightAbsorptionTowardSun);
    vec3 white = vec3(1, 1, 1);
    vec3 cloudColor = mix(_colA, white, clamp(lightEnergy * _colorOffset1, 0, 1));
    cloudColor = mix(_colB, cloudColor, clamp(pow(lightEnergy * _colorOffset2, 3), 0, 1));
    return _darkness + lightEnergy * _darkness * cloudColor;
}


void main() 
{
    // Get UV
    ivec2 dim = imageSize(sourceImage);
    vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim; 
    vec2 screenPoint = uv * 2.0 - 1.0;

    // Calculate ray start point, ray direction, and raymarching distance limit

    vec3 camLook = vec3(camera.view[0][2], camera.view[1][2], camera.view[2][2]);
    vec3 camRight = vec3(camera.view[0][0], camera.view[1][0], camera.view[2][0]);
    vec3 camUp = vec3(camera.view[0][1], camera.view[1][1], camera.view[2][1]);

    vec3 cameraPos = camera.cameraPosition.xyz;
    vec3 refPoint = cameraPos - camLook;
    float tanFov = tan(0.5f * DEG2RAD * 45.0f);      // fov = 45
    vec3 p = refPoint 
             + (1920.0f / 1080.0f) * screenPoint.x * tanFov * camRight 
             - screenPoint.y * tanFov * camUp;
    vec3 rayDir = normalize(p - cameraPos);

    vec2 rayToContainerInfo = rayBoxDst(_boundsMin, _boundsMax, cameraPos, (1 / rayDir));
    float dstToBox = rayToContainerInfo.x; 
    float dstInsideBox = rayToContainerInfo.y; 
    vec3 entryPoint = cameraPos + rayDir * dstToBox;
    float dstLimit = dstInsideBox; 

    float cosAngle = dot(rayDir, _lightDir);

    // Ray marching
    float dstTravelled = 0;
    float alpha = 1;
    vec3 lighting = vec3(0, 0, 0);
    const float sampleCount = 512;
    float stepSize = 0.1;
    vec3 rayPos = cameraPos;

    // For raymarch optimization
    float cloudTest = 0.0;
    int zeroDensitySampleCount = 0;
    float sampledDensityPrevious = -1.0;
    
    for (int j = 0; j < sampleCount; j++)
    {    
    // if (cloudTest > 0.0)
    // {      
    
        if (dstTravelled < dstLimit)
        {
            rayPos = entryPoint + (rayDir * dstTravelled);
            float density = sampleDensity(rayPos);
        
            if (density == 0.0 && sampledDensityPrevious == 0.0)
            {
                zeroDensitySampleCount++;
            }
        
            if (zeroDensitySampleCount < 11 && density != 0.0)
            { 
               // vec3 cloudLight = lightmarchAlongCone(rayPos, stepSize, cosAngle);
                vec3 cloudLight = lightmarch(rayPos);
                lighting += density * stepSize * alpha * cloudLight;
                alpha *= exp(-density * stepSize * _lightAbsorptionThroughCloud);                        
            }
            else 
            {
                cloudTest = 0.0;
                zeroDensitySampleCount = 0;
            }
            sampledDensityPrevious = density;
        }  
        dstTravelled += stepSize;


    //  }
    //  else
    //  {
    //      rayPos = entryPoint + (rayDir * dstTravelled);
    //      cloudTest = sampleDensity(rayPos);
    //      if (cloudTest == 0.0)
    //      {
    //          dstTravelled += stepSize * 2;
    //      }
    //      else 
    //      {
    //          dstTravelled -= stepSize;
    //      }
    //   }

    }


	ivec2 storePos = ivec2(gl_GlobalInvocationID.xy);
    vec3 col = vec3(0.6, 0.75, 0.8);
    col *= alpha;
    col += lighting;
    imageStore(targetImage, storePos, vec4(col, 1));
   // imageStore(targetImage, storePos, vec4(lighting, alpha));
}
