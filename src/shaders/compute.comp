#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WORKGROUP_SIZE 32

#define PI 3.14159265
#define E 2.718281828459
#define DEG2RAD 0.01745f

// TODO: check go through cloud?
#define ATMOSPHERE_RADIUS 6371000.0
#define ATMOSPHERE_RADIUS_INNER (ATMOSPHERE_RADIUS + 7500.0)
#define ATMOSPHERE_RADIUS_OUTER (ATMOSPHERE_RADIUS + 20000.0)
#define ATMOSPHERE_THICKNESS (ATMOSPHERE_RADIUS_OUTER - ATMOSPHERE_RADIUS_INNER)

layout(local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE) in;

layout (set = 0, binding = 0, rgba32f) uniform image2D targetImage;
layout (set = 1, binding = 0, rgba32f) uniform readonly image2D sourceImage;

layout(set = 2, binding = 0) uniform CameraObject {
    mat4 view;
    mat4 proj;
    vec4 cameraPosition;
} camera;

layout(set = 2, binding = 2) uniform CameraParamObject {
    float halfTanFOV;
    float aspectRatio;
} cameraParam;

layout(set = 2, binding = 1) uniform CameraObjectPrev {
    mat4 view;
    mat4 proj;
    vec4 cameraPosition;
} cameraPrev;

layout(set = 3, binding = 0) uniform sampler3D profileCloudShape;
layout(set = 3, binding = 1) uniform sampler3D detailCloudShape;
layout(set = 3, binding = 2) uniform sampler2D weatherMap;

layout(set = 4, binding = 0) uniform TimeObject {
    float deltaTime;
    float totalTime;
} time;

// structs
struct VoxelCloudModelingData {
    float mDimensionalProfile;
    float mDetailType;
    float mDensityScale;
};

struct VoxelCloudDensitySamples {
    float mProfile; // profile
    float mFull;    // detail
};

struct CloudRenderingRaymarchInfo {
    float mDistance;       // ray marching distance
    float mCloudDistance;  // distance to cloud
    float mStepSize;       // step size
};

struct Ray {
	vec3 mOrigin;
	vec3 mDirection;
};

struct Intersection {
    vec3 mNormal;
    vec3 mPoint;
    float mTime;
};

//--------------------------------------------------------
//					ATMOSPHERE FUNCTIONS
//--------------------------------------------------------
vec3 GetRelativePositionInAtmosphere(in vec3 pos, in vec3 earthCenter) {
   	return vec3( ( pos - vec3(earthCenter.x, ATMOSPHERE_RADIUS_INNER - ATMOSPHERE_RADIUS, earthCenter.z) )/ ATMOSPHERE_THICKNESS );
}

//--------------------------------------------------------
//					TOOL BOX FUNCTIONS
//--------------------------------------------------------
float ValueRemap(float inValue, float inOldMin, float inOldMax, float inMin, float inMax) {
    float old_min_max_range = (inOldMax - inOldMin);
    float clamped_normalized = clamp((inValue - inOldMin) / old_min_max_range, 0.0f, 1.0f);
    return inMin + (clamped_normalized * (inMax - inMin));
}

float ValueErosion(float inValue, float inOldMin) {
    // derrived from Set-Range, this function uses the oldMin to erode or inflate the input value. - inValues inflate while + inValues erode
    float old_min_max_range = (1.0 - inOldMin);
    float clamped_normalized = clamp((inValue - inOldMin) / old_min_max_range, 0.0f, 1.0f);
    return (clamped_normalized);
}

float GetFractionFromValue(float inValue, float inMin, float inMax) {
    return clamp((inValue - inMin) / (inMax - inMin), 0.0f, 1.0f);
}

//--------------------------------------------------------
//					Density Sample Functions
//--------------------------------------------------------

float GetUprezzedVoxelCloudDensity(vec3 samplePoint, float profileDensity, float densityScale) {
    // Step1 - Apply wind offset

    // Step2 - Sample noise

    // Step3 - Define Detail Erosion

    //       Wispy

    //       Billowy

    float uprezzed_density;

    // Step4 - Apply Detail Erosion

    return uprezzed_density;
}


VoxelCloudDensitySamples GetVoxelCloudDensitySamples(vec3 samplePoint, float inMipLevel, bool inHFDetails) {
    VoxelCloudDensitySamples densitySamples;

    // Sample profile: low frequency shape
	vec4 profileSample = textureLod(profileCloudShape, samplePoint, inMipLevel);
    float profileFBM = (lowFrequencyNoises.g * 0.625) + (lowFrequencyNoises.b * 0.25)  + (lowFrequencyNoises.a * 0.125);
    profileFBM = clamp(profileFBM, 0.0, 1.0);

    float profileDensity = ValueRemap(profileSample.r, (profileFBM  - 0.9), 1.0, 0.0, 1.0);
    

	if (profileDensity > 0.0f) {
        densitySamples.mProfile = profileDensity * ; // TODO: density scale
        // Erode Base cloud shape with higher frequency noise

    }

    return densitySamples;
}

//--------------------------------------------------------
//					Lighting Functions
//--------------------------------------------------------

//--------------------------------------------------------
//					Raymarching Functions
//--------------------------------------------------------
void RaymarchVoxelClouds(Ray ray, vec3 startPos, float start_t, float end_t, vec3 earthCenter, 
        out float accumDensity, out vec3 accumColor) {
	float _dot = ray.mDirection.y;
    const float maxSteps = floor(mix(35.0f, 60.0f, 1.0f - _dot)); // TODO: MANIPULATE
    const float atmosphereThickness = (end_t - start_t);	
	const float stepSize = (atmosphereThickness / maxSteps);

    accumDensity = 0.0f;
    accumColor = vec3(0.0f);

    vec3 pos = vec3(0.0f);
    vec3 samplePoint = vec3(0.0f);

    for (float t = start_t; t < end_t; t += stepSize) {
        vec3 colorPerSample = vec3(0.0);
        pos = ray.mOrigin + ray.mDirection * t;
        samplePoint = GetRelativePositionInAtmosphere(pos, earthCenter);
        samplePoint /= 8.0f; // TODO: MANIPULATE

        // Sam


    }
}

Ray GenerateRay(vec2 uv) {
    Ray ray;

    vec3 camLook =   normalize(vec3(camera.view[0][2], camera.view[1][2], camera.view[2][2]));
    vec3 camRight =  normalize(vec3(camera.view[0][0], camera.view[1][0], camera.view[2][0]));
    vec3 camUp =     normalize(vec3(camera.view[0][1], camera.view[1][1], camera.view[2][1]));

    vec2 screenPoint = uv * 2.0 - 1.0; // [-1, 1] -> [0, 1]
    // TODO: Jitter point with halton sequence

    vec3 cameraPos = camera.cameraPosition.xyz;
    vec3 refPoint = cameraPos - camLook;
    vec3 p = refPoint 
             + cameraParam.aspectRatio * screenPoint.x * cameraParam.halfTanFOV * camRight 
             - screenPoint.y * cameraParam.halfTanFOV * camUp;

    ray.mOrigin = cameraPos;
    ray.mDirection = normalize(p - cameraPos);

    return ray;
}

Intersection RaySphereIntersection(Ray ray, vec3 sphereCenter, float sphereRadius) {
	Intersection isect;
    isect.mTime = -1.0f;
    isect.mPoint = vec3(0.0);
    isect.mNormal = vec3(0.0, 1.0, 0.0);

    vec3 oc = ray.mOrigin - sphereCenter;
    oc /= sphereRadius;

    float a = dot(ray.mDirection, ray.mDirection);
    float b = 2.0f * dot(oc, ray.mDirection);
    float c = dot(oc, oc) - 1.0f;
    float discriminant = b * b - 4.0f * a * c;

    if (discriminant < 0.0f) {
        // no intersection
        return isect;
    } 

    float t = (-b - sqrt(discriminant)) / (2.0f * a);
    if (t < 0.0f) {
        t = (-b + sqrt(discriminant)) / (2.0f * a);
    }

    if (t >= 0.0) {
        vec3 p = vec3(oc + t * ray.mDirection);
        isect.mNormal = normalize(p);

        p *= sphereRadius;
        p += sphereCenter;

        isect.mPoint = p;
        isect.mTime = length(p - oc);
    }

    return isect;
}


void main() 
{
    // Get UV
    ivec2 dim = imageSize(sourceImage);

    // TODO: 1/16 of the pixels after reproject compute shader

    vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim; 
    Ray ray = GenerateRay(uv);

    // below horizon, return
    if (ray.mDirection.y < 0.0f) {
		imageStore(targetImage, ivec2(gl_GlobalInvocationID.xy), vec4(0.0f, 0.0f, 0.0f, 1.0f));
		return;
	}

    // Find start and end point of raymarching
    vec3 earthCenter = camera.cameraPosition.xyz;
    earthCenter.y = -ATMOSPHERE_RADIUS;
    Intersection atmosphereInnerIsect = RaySphereIntersection(ray, earthCenter, ATMOSPHERE_RADIUS_INNER);
	Intersection atmosphereOuterIsect = RaySphereIntersection(ray, earthCenter, ATMOSPHERE_RADIUS_OUTER);

    // Ray march
    vec3 accumColor = vec3(0.0f);
    float accumDensity = 0.0f;
    RaymarchVoxelClouds(ray, atmosphereInnerIsect.mPoint, atmosphereInnerIsect.mTime, atmosphereOuterIsect.mTime, earthCenter, accumDensity, accumColor);
	

}
